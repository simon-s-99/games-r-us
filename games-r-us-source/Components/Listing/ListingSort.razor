@rendermode InteractiveServer
@using games_r_us_source.Data
@using Microsoft.EntityFrameworkCore
@using games_r_us_source.Components.Listing
@using games_r_us_source.Components.Helpers
@using Data

@inject IDbContextFactory<ApplicationDbContext> dbContextFactory

@page "/sort"

<h3>Sort by</h3>

<select @bind="SelectedSortingOrder" @oninput="HandleSortChange">
    <option value="PriceAscending">Price ascending</option>
    <option value="PriceDescending">Price descending</option>
    <option value="DateAscending">Listing end date ascending</option>
    <option value="DateDescending">Listing end date descending</option>
    <option value="Alphabetically">Alphabetically</option>
</select>



@code {
    [Parameter]
    public Listing? Listing { get; set; } //for listings

    [Parameter]
    public Bid? HighestBid { get; set; } //For prices

    private List<Bid?> Sort { get; set; } = new List<Bid?>();
    private Listing? SortedListing { get; set; }

    [Parameter]
    public EventCallback<List<Listing>> OnSortResultsUpdated { get; set; }

    private SortingOrder? SelectedSortingOrder { get; set; } = null;
    private bool OrderByDescending { get; set; } = false;
    private bool OrderByAscending { get; set; } = false;

    private enum SortingOrder
    {
        PriceAscending,
        PriceDescending,
        DateAscending,
        DateDescending,
        Alphabetically
    }

    private async Task ApplySort(SortingOrder sortingOrder)
    {
        using var dbContext = dbContextFactory.CreateDbContext();

        SelectedSortingOrder = sortingOrder;

        // Fetch the listings along with their maximum price, either from the highest bid or the starting price
        var listingsWithMaxPrice = await dbContext.Listings
            .Select(l => new
            {
                Listing = l,
                MaxPrice = dbContext.Bids
                            .Where(b => b.ListingID == l.ID)
                            .OrderByDescending(b => b.Amount)
                            .Select(b => (decimal?)b.Amount)
                            .FirstOrDefault() ?? l.StartingPrice
            })
            .ToListAsync();

        switch (sortingOrder)
        {
            case SortingOrder.PriceAscending:
                listingsWithMaxPrice = listingsWithMaxPrice.OrderBy(l => l.MaxPrice).ToList();
                break;
            case SortingOrder.PriceDescending:
                listingsWithMaxPrice = listingsWithMaxPrice.OrderByDescending(l => l.MaxPrice).ToList();
                break;
            case SortingOrder.DateAscending:
                listingsWithMaxPrice = listingsWithMaxPrice.OrderBy(l => l.Listing.AuctionEnd).ToList();
                break;
            case SortingOrder.DateDescending:
                listingsWithMaxPrice = listingsWithMaxPrice.OrderByDescending(l => l.Listing.AuctionEnd).ToList();
                break;
            case SortingOrder.Alphabetically:
                listingsWithMaxPrice = listingsWithMaxPrice.OrderBy(l => l.Listing.Name).ToList();
                break;
        }

        var sortedListings = listingsWithMaxPrice.Select(x => x.Listing).ToList();
        await OnSortResultsUpdated.InvokeAsync(sortedListings);
    }

    private async Task HandleSortChange(ChangeEventArgs e)
    {
        if (Enum.TryParse<SortingOrder>(e.Value?.ToString(), out var sortingOrder))
        {
            await ApplySort(sortingOrder);
        }
    }
}


