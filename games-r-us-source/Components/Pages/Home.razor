@using Microsoft.AspNetCore.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.EntityFrameworkCore
@using games_r_us_source.Components.Listing
@using games_r_us_source.Components.Account
@using games_r_us_source.Components.Account.CustomComponents
@using games_r_us_source.Data
@using games_r_us_source.Hubs
@using games_r_us_source.Components.Helpers

@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider;
@inject NotificationState NotificationState

@implements IAsyncDisposable

@rendermode InteractiveServer

@page "/"

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

<LoginLogoutButton />

<ProfileButton />

<ListingCreate />

<ListingSearch OnSearchResultsUpdated="HandleSearchResults" />

<ListingSort OnSortResultsUpdated="HandleSorting" />

<!-- temp buttons to test signalr messaging -->
<button @onclick="Send" class="rounded-xl bg-orange-300 px-4 py-2">Click me</button>

<ul>
    @foreach (string notification in notifications)
    {
        <li>@notification</li>
    }
</ul>

<!-- Only here as a template for how to show content if
    user is logged  in or not.
-->
<AuthorizeView>
    <Authorized>
        @* Display this content here if user is logged in *@
        @* content accesses the AuthenticationState of the logged in user *@
        @context.User.Identity.Name
    </Authorized>
    <NotAuthorized>
        @* Display this content here if user is not logged in *@
    </NotAuthorized>
</AuthorizeView>

<ListingDisplayAll listings="@listings" />

<ListingsForUser />

@code {
    private HubConnection? hubConnection;
    private readonly List<string> notifications = new List<string>();
    private List<Listing> listings = new List<Listing>();

    private void HandleSearchResults(List<Listing> results)
    {
        listings = results; // Updates the list that is passed to ListingsDisplayAll
        StateHasChanged(); // <-- this might be unnecessary
    }

    private void HandleSorting(List<Listing> sortResults)
    {
        listings = sortResults;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        // Subscribes to changes in NotificationState class
        // allows us to re-render this component from e.g. a grand-child component
        NotificationState.OnChange += StateHasChanged;

        // Get the logged in user
        var authenticationState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var userName = authenticationState.User.Identity.Name;

        // send the logged in users name to signalR hub so that they can recieve notifications 
        if (userName is not null) // not strictly necessary but dis-allows non-logged in users from sending notifications
        {
            hubConnection = new HubConnectionBuilder()
                .WithUrl(NavigationManager.ToAbsoluteUri("/Notifications"), options =>
                {
                    // NOTE: Ideally we should do this with bearer tokens for better security.
                    //
                    // Pass username as header to our SignalR hub extension.
                    options.Headers.Add(new("UserName", userName));
                })
                .Build();

            hubConnection.On<string>("ReceiveNotificationAsync", notification =>
            {
                notifications.Add(notification);
                InvokeAsync(StateHasChanged);
            });

            await hubConnection.StartAsync();
        }
    }

    private async Task Send()
    {
        // Get the logged in user
        var authenticationState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var userName = authenticationState.User.Identity.Name;

        if (userName is not null) // not strictly necessary but dis-allows non-logged in users from sending notifications
        {
            NotificationState.SetNotificationDTO(new NotificationDTO("simon.t.sorqvist@gmail.com", "Success"));

            if (hubConnection is not null)
            {
                await hubConnection.SendAsync("SendNotificationTo", NotificationState.NotificationDTO);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }

        // Un-subscribes this component from NotificationState on dispose
        NotificationState.OnChange -= StateHasChanged;
    }
}
